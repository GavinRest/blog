import{_ as o,c as r,o as s,ae as n}from"./chunks/framework.BHrE6nLq.js";const c=JSON.parse('{"title":"OSPF 简介","description":"","frontmatter":{},"headers":[],"relativePath":"network/tcpip/layer3/ospf_introduction.md","filePath":"network/tcpip/layer3/ospf_introduction.md"}'),l={name:"network/tcpip/layer3/ospf_introduction.md"};function a(i,t,e,g,S,h){return s(),r("div",null,t[0]||(t[0]=[n('<h1 id="ospf-简介" tabindex="-1">OSPF 简介 <a class="header-anchor" href="#ospf-简介" aria-label="Permalink to &quot;OSPF 简介&quot;">​</a></h1><blockquote><p><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> 是一种链路状态协议，使用 <strong>SPF（Shortest Path First）</strong> 算法（<a href="./ospf_dijkstra.html">Dijkstra 算法</a>）计算路由域的拓扑结构。</p></blockquote><h2 id="ospf-基本原理" tabindex="-1">OSPF 基本原理 <a class="header-anchor" href="#ospf-基本原理" aria-label="Permalink to &quot;OSPF 基本原理&quot;">​</a></h2><ol><li>每台路由器都会在所有形成邻接关系的邻居之间发送 <strong>LSA（链路状态通告）</strong>。</li><li>每台收到邻居路由器 LSA 的设备会将其记录在 <strong>LSDB（链路状态数据库）</strong> 中，并将 LSA 拷贝并发送给所有邻居。</li><li>通过 LSA 的泛洪，整个<strong>区域内的</strong>路由器将同步形成相同的 <strong>LSDB</strong>（不同区域之间 LSA 不会泛洪）。</li><li>当 LSDB 同步完毕后，每台路由器以自身为根，使用 <strong>SPF 算法</strong> 计算无环拓扑图，以找到每个目的地的最短路径。</li><li>依据 SPF 算法生成的拓扑图，路由器构建自己的 <strong>路由表（Routing Table）</strong>。</li><li>路由表建立完成后，OSPF 进入稳定状态，仅通过 <strong>Hello 包</strong> 进行 Keepalive 维护邻居关系，并默认每 30 分钟泛洪一次 LSA 以更新链路状态。</li></ol><h2 id="ospf-的-5-种包类型与-6-种邻居状态" tabindex="-1">OSPF 的 5 种包类型与 6 种邻居状态 <a class="header-anchor" href="#ospf-的-5-种包类型与-6-种邻居状态" aria-label="Permalink to &quot;OSPF 的 5 种包类型与 6 种邻居状态&quot;">​</a></h2><h3 id="ospf-的-5-种包类型" tabindex="-1">OSPF 的 5 种包类型 <a class="header-anchor" href="#ospf-的-5-种包类型" aria-label="Permalink to &quot;OSPF 的 5 种包类型&quot;">​</a></h3><ol><li><strong>Hello</strong> - 发现和维持邻居关系。</li><li><strong>DBD（Database Description）</strong> - 数据库描述，用于同步 LSDB。</li><li><strong>LSR（Link-State Request）</strong> - 链路状态请求，用于请求特定的 LSA。</li><li><strong>LSU（Link-State Update）</strong> - 链路状态更新，传输 LSA。</li><li><strong>LS ACK（Link-State Acknowledgment）</strong> - LSA 确认，确保可靠传输。</li></ol><h3 id="ospf-的-6-种邻居状态" tabindex="-1">OSPF 的 6 种邻居状态 <a class="header-anchor" href="#ospf-的-6-种邻居状态" aria-label="Permalink to &quot;OSPF 的 6 种邻居状态&quot;">​</a></h3><ol><li><strong>INIT</strong> - 邻居发现阶段，收到对方 Hello 包。</li><li><strong>2-Way</strong> - 双向通信建立，选举 DR/BDR（指定路由器/备份指定路由器）。</li><li><strong>Exstart</strong> - 数据库同步初始化，协商 DBD 交换顺序。</li><li><strong>Exchange</strong> - 交换 DBD，传递 LSDB 概要信息。</li><li><strong>Loading</strong> - 发送 LSR 请求缺失的 LSA 并获取完整数据库。</li><li><strong>Full</strong> - LSDB 同步完成，形成完整邻接关系。</li></ol><h2 id="邻居与邻接" tabindex="-1"><a href="./ospf_neighbor.html">邻居与邻接</a> <a class="header-anchor" href="#邻居与邻接" aria-label="Permalink to &quot;[邻居与邻接](ospf_neighbor.md)&quot;">​</a></h2><ul><li><strong>邻居关系</strong>：通过 <strong>Hello 包</strong> 进行协商，达到 <strong>2-Way</strong> 状态。</li><li><strong>邻接关系</strong>：邻居关系建立后，<strong>LSDB 同步完毕</strong>，达到 <strong>Full</strong> 状态。</li></ul><h2 id="ospf-的优点" tabindex="-1">OSPF 的优点 <a class="header-anchor" href="#ospf-的优点" aria-label="Permalink to &quot;OSPF 的优点&quot;">​</a></h2><ol><li><strong>区域划分</strong>：通过 <strong>分区域架构</strong>（Area）减少 CPU 和内存消耗。</li><li><strong>无类路由</strong>：支持 <strong>VLSM（可变长子网掩码）</strong> 和 <strong>CIDR（无类域间路由）</strong>。</li><li><strong>负载均衡</strong>：支持 <strong>等价多路径（ECMP，Equal Cost Multi-Path）</strong> 负载均衡。</li><li><strong>组播传输</strong>：使用 <strong>224.0.0.5（全 OSPF 路由器）</strong> 和 <strong>224.0.0.6（DR/BDR 路由器）</strong> 组播地址，减少对非 OSPF 设备的影响。</li><li><strong>支持认证</strong>：可以配置 <strong>明文或 MD5 认证</strong>，增强安全性。</li><li><strong>外部路由标记</strong>：支持外部路由的 <strong>Tag 标记</strong> 以区分不同来源的路由。</li><li><strong>TOS（Type of Service）支持</strong>：历史上 OSPF 支持 <strong>TOS 路由选择</strong>，但因使用率低已在 <a href="https://tools.ietf.org/html/rfc2328" target="_blank" rel="noreferrer">RFC 2328</a> 中移除。</li></ol>',13)]))}const d=o(l,[["render",a]]);export{c as __pageData,d as default};
