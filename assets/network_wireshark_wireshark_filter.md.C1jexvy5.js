import{_ as e,c as a,o as r,ae as i}from"./chunks/framework.BHrE6nLq.js";const l="/images/wireshark/wireshark_capture_filter_expression.png",s="/images/wireshark/wireshark_capture_filter.png",p="/images/wireshark/wireshark_icmp.png",n="/images/wireshark/wireshark_icmp_type8.png",d="/images/wireshark/wireshark_tcp_reset.png",c="/images/wireshark/wireshark_dispaly_filter.png",o="/images/wireshark/wireshark_display_filter_button.png",b=JSON.parse('{"title":"wireshark 过滤器","description":"","frontmatter":{},"headers":[],"relativePath":"network/wireshark/wireshark_filter.md","filePath":"network/wireshark/wireshark_filter.md"}'),h={name:"network/wireshark/wireshark_filter.md"};function g(u,t,y,m,_,x){return r(),a("div",null,t[0]||(t[0]=[i('<h1 id="wireshark-过滤器" tabindex="-1">wireshark 过滤器 <a class="header-anchor" href="#wireshark-过滤器" aria-label="Permalink to &quot;wireshark 过滤器&quot;">​</a></h1><p>Wireshark 过滤器分为两种，捕获过滤器与显示过滤器。</p><ul><li><p>捕获过滤器：当进行数据包捕获时，只有那些满足给定的包含/排除表达式的数据包会被捕获。</p></li><li><p>显示过滤器：该过滤器根据指定的表达式用于一个已捕获的数据包集合，它将隐藏不想显示的数据包，或者只显示那些需要的数据包。</p></li></ul><h3 id="捕获过滤器-capture-filter" tabindex="-1">捕获过滤器（capture filter） <a class="header-anchor" href="#捕获过滤器-capture-filter" aria-label="Permalink to &quot;捕获过滤器（capture filter）&quot;">​</a></h3><hr><p>捕获过滤器可减少抓取文件体积，使用 BPF(Berkeley packet filter) 语法。tcpdump 也同样支持 BPF 语法。</p><p>BPF 语法：使用 BPF 语法创建的过滤器被称为 expression（表达式），并且每个表达式包含一个或多个primitives（原语）。每个原语包含一个或多个qualifiers（限定词），然后跟着一个ID 名字或者数字</p><ul><li>BPF 限定词</li></ul><table tabindex="0"><thead><tr><th>限定词</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Type</td><td>指出名字或数字所代表的意义</td><td>host、net、port</td></tr><tr><td>Direction</td><td>指明传输方向是前往还是来自名字或数字</td><td>src、dst</td></tr><tr><td>Proto</td><td>限定所要匹配的协议</td><td>Ether、ip、tcp、udp、http、ftp</td></tr></tbody></table><ul><li><p>表达式结构（expression） <img src="'+l+'" alt="wireshark_capture_filter_expression"></p></li><li><p>表达式(expression)：由多个原语(primitive)组成。</p></li><li><p>type</p><ul><li>host：双向主机</li><li>port：双向端口</li><li>net：子网 net 192.168.0.0/24</li><li>portrange：端口范围</li></ul><p><img src="'+s+`" alt="wireshark_capture_filter"></p></li><li><p>原语运算符</p><ul><li><p>与：&quot;&amp;&amp;&quot; 或者 &quot;and&quot;</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>src host 192.168.0.10 &amp;&amp; port 80</span></span></code></pre></div></li><li><p>或：&quot;||&quot; 或者 &quot;or&quot;</p></li><li><p>非：&quot;!&quot; 或者 &quot;not&quot;</p></li></ul></li><li><p>BPF 语法参考</p><ul><li><p>捕获 tcp 协议 源/目的端口范围：<code>tcp and src or dst portrange 6000-8000</code></p></li><li><p>length &gt; 100 数据包：<code>tcp and src or dst portrange 80-4000 and greater 100</code></p></li></ul></li><li><p>tcpdump BPF 语法参考</p><ul><li><p>抓取端口范围：<code>tcpdump -i ens38 &#39;tcp and src or dst portrange 6000-8000&#39;</code></p></li><li><p>大文件中筛选：<code>tcpdump -r packets.pcap &#39;tcp dst port 80&#39; -w http.pcap</code></p></li><li><p>指定语法文件：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>root@server:~# cat portrange.bpf </span></span>
<span class="line"><span>tcp and src or dst portrange 6000-8000</span></span>
<span class="line"><span>root@server:~# tcpdump -i ens33 -F portrange.bpf</span></span></code></pre></div></li></ul></li></ul><h3 id="捕获过滤器高级用法" tabindex="-1">捕获过滤器高级用法 <a class="header-anchor" href="#捕获过滤器高级用法" aria-label="Permalink to &quot;捕获过滤器高级用法&quot;">​</a></h3><hr><p>BPF 语法可以通过检查协议头中的每一个字节来创建基于那些数据的特殊过滤器</p><ul><li><p>字节转换：</p><ul><li><p>1byte == 2 个 16 进制数</p></li><li><p>1byte == 8 个 bit</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>二进制：0 	0 	0 	0 	0 	0 	0	0</span></span>
<span class="line"><span>十进制：128 64  32  16	8	4	2	1</span></span></code></pre></div></li></ul></li><li><p>通过偏移值定义过滤器</p><ul><li>格式：协议[字节位置] == value</li></ul></li><li><p>示例1：过滤 icmp echo 报文，即协议第1个字节</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># icmp 协议第一个字节 == 8 即 echo 报文</span></span>
<span class="line"><span>icmp[0]==8</span></span></code></pre></div><p><img src="`+p+'" alt="wireshark_icmp"><img src="'+n+`" alt="wireshark_icmp_type8"></p></li><li><p>示例2：过滤 tcp reset 报文</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># tcp 包头第 13 个 byte 是 flag 字段，reset 置位时十进制数 == 4（0100）。</span></span>
<span class="line"><span>tcp[13]&amp;4==4</span></span></code></pre></div><p><img src="`+d+'" alt="wireshark_tcp_reset"></p></li><li><p>常用捕获过滤器</p></li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">过滤器</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">tcp[13]&amp;32==32</td><td style="text-align:center;">设置了URG 位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp[13]&amp;16==16</td><td style="text-align:center;">设置了ACK 位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp[13]&amp;8==8</td><td style="text-align:center;">设置了PSH 位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp[13]&amp;4==4</td><td style="text-align:center;">设置了RST 位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp[13]&amp;2==2</td><td style="text-align:center;">设置了SYN 位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp[13]&amp;1==1</td><td style="text-align:center;">设置了FIN 位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp[13]==18</td><td style="text-align:center;">TCP SYN-ACK 数据包</td></tr><tr><td style="text-align:center;">ether host 00:00:00:00:00:00</td><td style="text-align:center;">流入或流出你MAC 地址的流量</td></tr><tr><td style="text-align:center;">!ether host 00:00:00:00:00:00</td><td style="text-align:center;">不流入或流出你MAC 地址的流量</td></tr><tr><td style="text-align:center;">broadcast</td><td style="text-align:center;">仅广播流量</td></tr><tr><td style="text-align:center;">icmp</td><td style="text-align:center;">ICMP 流量</td></tr><tr><td style="text-align:center;">icmp[0:2]</td><td style="text-align:center;">ICMP 目标不可达、主机不可达</td></tr><tr><td style="text-align:center;">ip</td><td style="text-align:center;">仅IPv4 流量</td></tr><tr><td style="text-align:center;">ip6</td><td style="text-align:center;">仅IPv6 流量</td></tr><tr><td style="text-align:center;">udp</td><td style="text-align:center;">仅UDP 流量</td></tr></tbody></table><h3 id="显示过滤器-display-filter" tabindex="-1">显示过滤器（display filter） <a class="header-anchor" href="#显示过滤器-display-filter" aria-label="Permalink to &quot;显示过滤器（display filter）&quot;">​</a></h3><hr><p>显示过滤器更为强大，数据包详情的每个字段都可以作为筛选条件</p><ul><li>常用显示过滤器</li></ul><table tabindex="0"><thead><tr><th style="text-align:center;">过滤器</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:center;">!tcp.port==3389</td><td style="text-align:center;">排除RDP 流量</td></tr><tr><td style="text-align:center;">tcp.flags.syn==1</td><td style="text-align:center;">具有SYN 标志位的TCP 数据包</td></tr><tr><td style="text-align:center;">tcp.flags.rst==1</td><td style="text-align:center;">具有RST 标志位的TCP 数据包</td></tr><tr><td style="text-align:center;">!arp</td><td style="text-align:center;">排除ARP 流量</td></tr><tr><td style="text-align:center;">http</td><td style="text-align:center;">所有HTTP 流量</td></tr><tr><td style="text-align:center;">tcp.port==23</td><td style="text-align:center;">文本管理流量（Telnet 或FTP）</td></tr></tbody></table><ul><li><p>一招打天下</p><p><img src="'+c+'" alt="wireshark_dispaly_filter"></p></li><li><p>保存显示过滤器（如有特别常用且复杂的显示过滤器，可以加 label保存）</p></li></ul><p><img src="'+o+'" alt="wireshark_display_filter_button"></p>',22)]))}const f=e(h,[["render",g]]);export{b as __pageData,f as default};
