import{_ as a,c as i,o as n,ae as t}from"./chunks/framework.BHrE6nLq.js";const c=JSON.parse('{"title":"Python 装饰器","description":"","frontmatter":{},"headers":[],"relativePath":"develop/python/advanced/decorators.md","filePath":"develop/python/advanced/decorators.md"}'),e={name:"develop/python/advanced/decorators.md"};function l(h,s,p,r,k,o){return n(),i("div",null,s[0]||(s[0]=[t(`<h1 id="python-装饰器" tabindex="-1">Python 装饰器 <a class="header-anchor" href="#python-装饰器" aria-label="Permalink to &quot;Python 装饰器&quot;">​</a></h1><h2 id="装饰器" tabindex="-1">装饰器 <a class="header-anchor" href="#装饰器" aria-label="Permalink to &quot;装饰器&quot;">​</a></h2><p>装饰器其实就是一个函数，它可以在<strong>不修改原函数代码</strong>的情况下，给这个函数加一些额外的功能。</p><h3 id="装饰器作用" tabindex="-1">装饰器作用 <a class="header-anchor" href="#装饰器作用" aria-label="Permalink to &quot;装饰器作用&quot;">​</a></h3><ul><li><strong>避免重复代码</strong>：如果有很多函数需要相同的功能（比如打印日志），可以把这个功能放到装饰器里，不用每次都写。</li><li><strong>增强功能</strong>：装饰器可以在原函数的前后做一些额外的操作，比如在执行函数前先打印日志，或者计算函数运行的时间。</li></ul><h3 id="装饰器示例" tabindex="-1">装饰器示例 <a class="header-anchor" href="#装饰器示例" aria-label="Permalink to &quot;装饰器示例&quot;">​</a></h3><p>装饰器本质是一个函数，它接受另一个函数作为参数，并返回一个新的函数。</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> decorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Before function call&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        func()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 调用原函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;After function call&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wrapper</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">@decorator</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 这行就相当于把 greet 函数“包装”起来</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">():</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">greet()</span></span></code></pre></div>`,8)]))}const E=a(e,[["render",l]]);export{c as __pageData,E as default};
