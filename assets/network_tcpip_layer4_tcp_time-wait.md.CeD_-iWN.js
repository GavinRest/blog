import{_ as t}from"./chunks/tcp四次挥手.bfT_YmTX.js";import{_ as i,c as a,o as c,ae as o}from"./chunks/framework.BHrE6nLq.js";const p="/images/tcpip/layer4/TIME_WAIT_ACK%E4%B8%A2%E5%A4%B1.png",l="/images/tcpip/layer4/TIME_WAIT_RST.png",s="/images/tcpip/layer4/TIME_WAIT_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%B6%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%85.png",u=JSON.parse('{"title":"tcpTIMEWAIT","description":"","frontmatter":{},"headers":[],"relativePath":"network/tcpip/layer4/tcp_time-wait.md","filePath":"network/tcpip/layer4/tcp_time-wait.md"}'),_={name:"network/tcpip/layer4/tcp_time-wait.md"};function d(n,e,r,T,I,m){return c(),a("div",null,e[0]||(e[0]=[o(`<h1 id="tcptimewait" tabindex="-1">tcpTIMEWAIT <a class="header-anchor" href="#tcptimewait" aria-label="Permalink to &quot;tcpTIMEWAIT&quot;">​</a></h1><ul><li><p>回顾 TCP 四次挥手：正常情况下服务端收到了 <code>ACK</code> 消息并关闭当前 TCP 连接，客户端等待</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> msl 查看</span></span>
<span class="line"><span> cat /proc/sys/net/ipv4/tcp_fin_timeout</span></span></code></pre></div></li><li><p>2msl(Maximum Segment Lifetime) 进入 CLOSED。<img src="`+t+'" alt="tcp四次挥手"></p></li></ul><p>从上述过程中，我们会发现 <code>TIME_WAIT</code> 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 <code>CLOSED</code> 状态，进入 <code>TIME_WAIT</code> 的客户端需要等待 2 MSL 才可以真正关闭连接。</p><h3 id="一、没有-time-wait、或-time-wait-时间过短的问题" tabindex="-1">一、没有 TIME_WAIT、或 TIME_WAIT 时间过短的问题 <a class="header-anchor" href="#一、没有-time-wait、或-time-wait-时间过短的问题" aria-label="Permalink to &quot;一、没有 TIME_WAIT、或 TIME_WAIT 时间过短的问题&quot;">​</a></h3><ul><li><p>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</p><ul><li><p>场景1：由于丢包（客户端发送的 <code>ACK</code> 丢失），服务端没有收到 <code>ACK</code> 消息，服务器重新发送 <code>FIN</code> 关闭连接并等待新的 <code>ACK</code> 消息。如果没有 TIME_WAIT、或 TIME_WAIT 时间过短客户端无法收到重传的 <code>FIN</code> 包导致四次挥手服务优雅的完成。</p><p><img src="'+p+'" alt="TIME_WAIT_ACK丢失"></p></li><li><p>场景2：假设刚好客户端以相同端口发送 <code>SYN</code>，那么服务器端就会返回 <code>RST</code>。</p><p><img src="'+l+'" alt="TIME_WAIT_RST"></p></li><li><p>场景3：由于 TIME_WAIT 过短，客户端用之前的端口新建 session。客户端收到了上个会话服务端延时的数据包。</p><p><img src="'+s+'" alt="TIME_WAIT_服务器延时数据包"></p></li></ul></li></ul><h3 id="三、解决-time-wait-过多新会话无法建立" tabindex="-1">三、解决 TIME_WAIT 过多新会话无法建立 <a class="header-anchor" href="#三、解决-time-wait-过多新会话无法建立" aria-label="Permalink to &quot;三、解决 TIME_WAIT 过多新会话无法建立&quot;">​</a></h3><ol><li>使用 <code>SO_LINGER</code> 选项并设置暂存时间 <code>l_linger</code> 为 0，在这时如果我们关闭 TCP 连接，内核就会直接丢弃缓冲区中的全部数据并向服务端发送 <code>RST</code> 消息直接终止当前的连接。</li><li>使用 <code>net.ipv4.tcp_tw_reuse</code> 选项，通过 TCP 的时间戳选项允许内核重用处于 <code>TIME_WAIT</code> 状态的 TCP 连接。</li><li>修改 <code>net.ipv4.ip_local_port_range</code> 选项中的可用端口范围，增加可同时存在的 TCP 连接数上限</li><li>TCP 配置项 <code>net.ipv4.tcp_tw_recycle</code> 已经在 Linux 4.12 中移除，所以我们不能再通过该配置解决 <code>TIME_WAIT</code> 设计带来的问题。</li></ol>',7)]))}const h=i(_,[["render",d]]);export{u as __pageData,h as default};
