import{_ as i,c as a,o as n,ae as h}from"./chunks/framework.BHrE6nLq.js";const g=JSON.parse('{"title":"Dijkstra 算法","description":"","frontmatter":{},"headers":[],"relativePath":"network/tcpip/layer3/ospf_dijkstra.md","filePath":"network/tcpip/layer3/ospf_dijkstra.md"}'),t={name:"network/tcpip/layer3/ospf_dijkstra.md"};function p(l,s,k,e,E,r){return n(),a("div",null,s[0]||(s[0]=[h(`<h1 id="dijkstra-算法" tabindex="-1">Dijkstra 算法 <a class="header-anchor" href="#dijkstra-算法" aria-label="Permalink to &quot;Dijkstra 算法&quot;">​</a></h1><h2 id="_1-什么是-dijkstra-算法" tabindex="-1">1. 什么是 Dijkstra 算法？ <a class="header-anchor" href="#_1-什么是-dijkstra-算法" aria-label="Permalink to &quot;1. 什么是 Dijkstra 算法？&quot;">​</a></h2><p>Dijkstra 算法由荷兰计算机科学家 <strong>Edsger W. Dijkstra</strong> 在 1956 年提出，旨在解决 <strong>单源最短路径</strong> 问题。该算法广泛应用于路由、图像处理等领域。</p><h2 id="_2-dijkstra-基本原理" tabindex="-1">2. Dijkstra 基本原理 <a class="header-anchor" href="#_2-dijkstra-基本原理" aria-label="Permalink to &quot;2. Dijkstra 基本原理&quot;">​</a></h2><h3 id="用坐地铁的方式比喻" tabindex="-1">用坐地铁的方式比喻 <a class="header-anchor" href="#用坐地铁的方式比喻" aria-label="Permalink to &quot;用坐地铁的方式比喻&quot;">​</a></h3><p>找到从你家附近的地铁站到某个目的地的<strong>最快路线</strong>。Dijkstra 算法逻辑如下：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>你拿到了一张地铁地图，上面标有所有地铁站（节点）和它们之间的线路（边），每条线路的<strong>行车时间</strong>（权重）。</li><li>你把自己所在的地铁站（起点）的时间标记为 <code>0</code>，其他所有站点的时间暂时标记为 <code>∞</code>，表示还不知道怎么过去。</li></ul></li><li><p><strong>选择当前最近的站点</strong>：</p><ul><li>你查看所有已经记录的站点，找到乘车时间最短的那个，比如 <code>A</code>（你当前的站点）。</li><li>你看看从 <code>A</code> 直接可以到达哪些站，比如 <code>B</code> 和 <code>C</code>。</li></ul></li><li><p><strong>更新最快路线</strong>：</p><ul><li>计算 <code>A -&gt; B</code> 和 <code>A -&gt; C</code> 所需的时间。</li><li>如果发现去某个站的新路线比之前记录的更快，就更新它的最快时间。</li><li>例如，如果 <code>A -&gt; B</code> 需要 <strong>1 分钟</strong>，<code>A -&gt; C</code> 需要 <strong>4 分钟</strong>，那么更新到 <code>B</code> 的时间为 <code>1</code> 分钟，到<code>C</code> 的时间为 <code>4</code> 分钟。</li></ul></li><li><p><strong>继续扩展</strong>：</p><ul><li>你再次选择当前已知最快的站点，比如 <code>B</code>。</li><li>你看看 <code>B</code> 可以到达哪里，比如 <code>C</code> 和 <code>D</code>，然后尝试更新 <code>C</code> 和 <code>D</code> 的最快时间。</li><li>例如，如果 <code>B -&gt; C</code> 需要 <strong>2 分钟</strong>，那么 <code>A -&gt; B -&gt; C</code> 总共是 <code>1 + 2 = 3</code> 分钟，比 <code>A -&gt; C</code> 直接过去的 <strong>4 分钟</strong> 更快，所以更新 <code>C</code> 的时间为 <strong>3 分钟</strong>，最短路径为 <code>A -&gt; B -&gt; C</code>。</li></ul></li><li><p><strong>重复这个过程</strong>，每次选择当前已知最快的站点去扩展，直到所有的站点都计算完毕。</p></li></ol><h2 id="_3-代码实现" tabindex="-1">3. 代码实现 <a class="header-anchor" href="#_3-代码实现" aria-label="Permalink to &quot;3. 代码实现&quot;">​</a></h2><p>下面是 Python 版本的 Dijkstra 算法：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heapq</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dijkstra</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(graph, start):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 初始化：所有点的最短距离设为无穷大，起点设为 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shortest_paths </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {node: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;inf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shortest_paths[start] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, start)]  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># (当前已知的最短距离, 节点)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pq:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        current_distance, current_node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heapq.heappop(pq)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 取出当前距离最短的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_distance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shortest_paths[current_node]:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            continue</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 如果当前节点的距离已经被更新过，就跳过</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> neighbor, weight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> graph[current_node].items():</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            distance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_distance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> weight  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 计算从当前节点到邻居的距离</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> distance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shortest_paths[neighbor]:  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 发现更短的路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                shortest_paths[neighbor] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> distance  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 更新距离</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                heapq.heappush(pq, (distance, neighbor))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 把这个邻居加入队列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shortest_paths</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;&#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    # 地铁拓扑图</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         A</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">       /   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      1      4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     /        </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    B ---2--- C</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     \\       /</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      5     1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">       \\   /</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         D</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;&#39;&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 拓扑图用 json 表示</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;D&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;D&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;D&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 计算从 &#39;A&#39; 开始的最短路径</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shortest_paths </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dijkstra(graph, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shortest_paths)</span></span></code></pre></div><h2 id="_4-为什么使用-heapq" tabindex="-1">4. 为什么使用 <code>heapq</code>？ <a class="header-anchor" href="#_4-为什么使用-heapq" aria-label="Permalink to &quot;4. 为什么使用 \`heapq\`？&quot;">​</a></h2><p>在 Dijkstra 算法中，我们需要<strong>不断找到当前最短路径的节点</strong>并<strong>更新邻居的路径</strong>，这里就用到了 <code>heapq</code>（最小堆）。</p><ul><li><strong><code>heapq.heappop(pq)</code></strong>：每次取出当前已知的最短路径节点。</li><li><strong><code>heapq.heappush(pq, (distance, neighbor))</code></strong>：发现更短路径时，把 <code>(新的距离, 邻居)</code> 放入堆。</li></ul><h3 id="heapq-的作用示例" tabindex="-1"><code>heapq</code> 的作用示例 <a class="header-anchor" href="#heapq-的作用示例" aria-label="Permalink to &quot;\`heapq\` 的作用示例&quot;">​</a></h3><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pq </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;D&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">heapq.heapify(pq)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 让它变成最小堆</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(heapq.heappop(pq))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 取出 (1, &#39;B&#39;)，因为 1 是最小的</span></span></code></pre></div><h3 id="为什么-heapq-更快" tabindex="-1">为什么 <code>heapq</code> 更快？ <a class="header-anchor" href="#为什么-heapq-更快" aria-label="Permalink to &quot;为什么 \`heapq\` 更快？&quot;">​</a></h3><p>如果用普通列表找最短路径：</p><ul><li><strong>找最小值</strong>：需要 <code>O(n)</code> 遍历所有节点。</li><li><strong>更新列表</strong>：插入新路径可能也要 <code>O(n)</code>。</li></ul><p>但 <code>heapq</code> 维护<strong>最小堆</strong>，保证堆顶始终是最短路径，时间复杂度：</p><ul><li><strong>取最小值（heappop）</strong>：<code>O(log n)</code>。</li><li><strong>插入新路径（heappush）</strong>：<code>O(log n)</code>。</li></ul><p>所以 Dijkstra 算法的总复杂度是 <code>O((V + E) log V)</code>，比普通实现快很多！🚀</p><h2 id="_5-结果解释" tabindex="-1">5. 结果解释 <a class="header-anchor" href="#_5-结果解释" aria-label="Permalink to &quot;5. 结果解释&quot;">​</a></h2><p>执行后，代码会输出从 <code>A</code> 到其他点的最短路径，例如：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;C&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;D&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li><code>A -&gt; B</code>：最短路径是 <code>1</code> 分钟</li><li><code>A -&gt; C</code>：最短路径是 <code>A -&gt; B -&gt; C</code>，需要 <code>3</code> 分钟</li><li><code>A -&gt; D</code>：最短路径是 <code>A -&gt; B -&gt; C -&gt; D</code>，需要 <code>4</code> 分钟</li></ul>`,25)]))}const o=i(t,[["render",p]]);export{g as __pageData,o as default};
